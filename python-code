import random
import mysql.connector

# Connect to the database
db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="12345",
    database="db2"
)

# Create a cursor to execute SQL queries
cursor = db.cursor()

# Define classes

class Chef:
    def __init__(self, chef_id, first_name, last_name, age, years_of_experience, expertise, cuisine_id, training_level, contact_number, date_of_birth):
        self.chef_id = chef_id
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
        self.years_of_experience = years_of_experience
        self.expertise = expertise
        self.cuisine_id = cuisine_id
        self.training_level = training_level
        self.contact_number = contact_number
        self.date_of_birth = date_of_birth
        self.rating = []

class Judge:
    def __init__(self, chef_id):
        self.chef_id = chef_id

class Cuisine:
    def __init__(self, cuisine_id, name):
        self.cuisine_id = cuisine_id
        self.name = name

def update_appearances_table(selected_chefs):
    for chef in selected_chefs:
        # Check if chef already exists in the appearances table
        cursor.execute("SELECT total_appearances FROM appearances WHERE chef_id = %s", (chef.chef_id,))
        result = cursor.fetchone()

        if result:
            # Chef already exists, update total appearances
            total_appearances = result[0] + 1
            cursor.execute("UPDATE appearances SET total_appearances = %s WHERE chef_id = %s", (total_appearances, chef.chef_id))
        else:
            # Chef doesn't exist, insert new record
            cursor.execute("INSERT INTO appearances (chef_id, total_appearances) VALUES (%s, 1)", (chef.chef_id,))
    
    # Commit changes to the database
    db.commit()

def insert_selected_recipe(episode_id, recipe_name):
    try:
        # Insert the new recipe with year 2002
        cursor.execute("INSERT INTO selected_recipes (episode, recipe_name, year) VALUES (%s, %s, %s)", (episode_id, recipe_name, 2002))
        print(f"Inserted recipe '{recipe_name}' for episode {episode_id}.")
        db.commit()
    except mysql.connector.Error as err:
        print(f"Error: {err}")
        db.rollback()

# Function to calculate score
def calculate_score(chef):
    if chef.rating:
        avg_rating = sum(chef.rating) / len(chef.rating)
    else:
        avg_rating = 0

    score = avg_rating 
    return score

def insert_rating(chef_id, national_cuisine, user_id, rating):
    sql = "INSERT INTO Ratings (chef_id, national_cuisine, user_id, rating) VALUES (%s, %s, %s, %s)"
    val = (chef_id, national_cuisine, user_id, rating)
    cursor.execute(sql, val)
    db.commit()

def select_random_recipe():
    # Select a random recipe_id from 1 to 10
    recipe_id = random.randint(1, 10)

    # Fetch the recipe name based on the selected recipe_id
    cursor.execute("SELECT recipe_name FROM Recipes WHERE recipe_id = %s", (recipe_id,))
    recipe = cursor.fetchone()

    if not recipe:
        raise ValueError(f"No recipe found for recipe_id {recipe_id}")

    return recipe[0]  # Return the recipe name

# Function to update the winners table
def update_winners_table(winner_id, episode):
    sql = "INSERT INTO winners (chef_id, episode) VALUES (%s, %s)"
    val = (winner_id, episode)
    cursor.execute(sql, val)
    db.commit()

# Function to insert selected chefs into the selected_chefs table
def insert_selected_chefs(episode_id, selected_chefs):
    for chef in selected_chefs:
        sql = """INSERT INTO selected_chefs (episode, chef_id, first_name, last_name, contact_number, date_of_birth, age, years_of_experience, expertise, cuisine_id, training_level) 
                 VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)"""
        val = (episode_id, chef.chef_id, chef.first_name, chef.last_name, chef.contact_number, chef.date_of_birth, chef.age, chef.years_of_experience, chef.expertise, chef.cuisine_id, chef.training_level)
        cursor.execute(sql, val)
    db.commit()

# Main code for the competition
for episode in range(10):
    print(f"Episode {episode + 1}:")

    # Fetch all chefs from the database
    cursor.execute("SELECT * FROM chefs")
    rows = cursor.fetchall()

    # List to store Chef objects
    chefs = []

    # Create Chef objects from the retrieved data
    for row in rows:
        chef_id, first_name, last_name, contact_number, date_of_birth, age, years_of_experience, expertise, cuisine_id, training_level = row
        chef = Chef(chef_id, first_name, last_name, age, years_of_experience, expertise, cuisine_id, training_level, contact_number, date_of_birth)
        chefs.append(chef)

    # Shuffle the list of chefs for random selection
    random.shuffle(chefs)

    # Randomly select 10 chefs for this episode
    selected_chefs = random.sample(chefs, 10)

    # Update the appearances table
    update_appearances_table(selected_chefs)

    # Insert selected chefs into the selected_chefs table
    insert_selected_chefs(episode + 1, selected_chefs)

    # Remove selected chefs from the list to ensure judges are selected from the remaining chefs
    for chef in selected_chefs:
        chefs.remove(chef)

    # List to store judges for this episode
    episode_judges = []

    # Randomly select 3 judges from the remaining chefs for this episode
    episode_judges.extend(random.sample(chefs, min(3, len(chefs))))

    # Insert judges into the judges table for this episode
    for judge in episode_judges:
        cursor.execute("INSERT INTO judges (first_name, last_name, contact_number, date_of_birth, age, years_of_experience, expertise, cuisine_id, training_level) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)",
                       (judge.first_name, judge.last_name, judge.contact_number, judge.date_of_birth, judge.age, judge.years_of_experience, judge.expertise, judge.cuisine_id, judge.training_level))
        db.commit()

    # Clear ratings for all chefs before each episode
    for chef in chefs:
        chef.rating = []

    # Execute recipe for each chef
    for chef in selected_chefs:
        # Generate a random recipe
        try:
            recipe = select_random_recipe()
        except ValueError as e:
            print(f"Error selecting recipe: {e}")
            continue

        # Debugging print statements
        print(f"Inserting recipe for Episode {episode + 1}: {recipe}")
        
        insert_selected_recipe(episode + 1, recipe)

        # Print the chef's name and the generated recipe
        print(f"{chef.first_name} executes recipe '{recipe}'")

        # Judge the recipe
        ratings = [random.randint(1, 5) for _ in range(len(episode_judges))]  # Generates ratings for each judge
        print(f"Ratings for {chef.first_name}: {ratings}")

        # Insert ratings into the Ratings table
        for rating, judge in zip(ratings, episode_judges):
            insert_rating(chef.chef_id, None, judge.chef_id, rating)  # Set national_cuisine to None for simplicity
            # Append rating to chef's rating list
            chef.rating.append(rating)

    # Calculate total scores for this episode and find the winner
    winner = max(selected_chefs, key=calculate_score)
    print(f"Winner of Episode {episode + 1}: {winner.first_name} {winner.last_name} (Chef {winner.chef_id})\n")

    # Add the winner to the winners table
    update_winners_table(winner.chef_id, episode + 1)

# Close cursor and database connection
cursor.close()
db.close()
